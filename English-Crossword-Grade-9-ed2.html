<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ENGLISH CROSSWORD PUZZLE Grade 9 - Kurikulum Merdeka</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Segoe+UI:wght@400;700&family=Franklin+Gothic+Medium&family=Arial&display=swap" rel="stylesheet">
<style>
/* Reset & Base Styles */
html, body {
    height: 100%; /* Make html and body take full viewport height */
    margin: 0;
    padding: 0; /* Remove body padding here, move it to inner container if needed */
    overflow: hidden; /* Prevent body scrolling */
}

body {
    font-family: "Segoe UI", "Franklin Gothic Medium", "Arial", sans-serif;
    font-size: small;
    cursor: default;
    background-color: #f4f7f6; /* Light background for the page */
    display: flex; /* Use flexbox for the body to manage content */
    flex-direction: column; /* Stack children vertically */
}

/* New wrapper for the main content */
.main-app-wrapper {
    flex-grow: 1; /* Allow it to take available space */
    display: flex;
    flex-direction: column; /* Stack header and container */
    padding: 20px; /* Original body padding */
    box-sizing: border-box; /* Include padding in height calculation */
    overflow-y: auto; /* Allow scrolling within this wrapper if content overflows */
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
}

h1, h2, h3, h4, h5, h6 {
    color: #5d6a86;
    font-family: "Segoe UI", "Franklin Gothic Medium", "Arial", sans-serif;
}

h1 {
    margin-bottom: 0.5em; /* Adjust heading margin */
}

h3 {
    margin-top: -0.5em; /* Adjust subheading margin for blog link */
    color: #808080; /* Softer color for the blog link */
    font-size: 0.9em;
}

/* Layout Classes */
.container {
    display: flex;
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
    gap: 20px; /* Space between crossword and answer box */
    justify-content: center; /* Center the content */
    max-width: 1200px; /* Max width for content */
    margin: 0 auto; /* Center container */
    flex-grow: 1; /* Allow container to take available space */
    align-items: flex-start; /* Align items to the start vertically */
}

/* Crossword Specific Styles */
.ecw-answerbox {
    color: black;
    background-color: #FFFAF0;
    border: 1px solid #808080;
    padding: 0.75em;
    width: 280px; /* Increased width for better readability */
    box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Subtle shadow */
    border-radius: 5px; /* Slightly rounded corners */
}

.ecw-box {
    border: 1pt solid;
    cursor: pointer;
    /* Use clamp for responsive sizing */
    height: clamp(2em, 8vw, 2.8em);
    width: clamp(2em, 8vw, 2.8em);
    font-size: clamp(1em, 4vw, 1.5em);
    line-height: clamp(2em, 8vw, 2.8em); /* Center text vertically */

    font-weight: bold;
    overflow: hidden;
    text-align: center;
    box-sizing: border-box; /* Include padding and border in element's total width and height */
    transition: background-color 0.2s, border-color 0.2s; /* Smooth transitions */
    position: relative; /* For active cell indicator */
    user-select: none; /* Prevent text selection */
}

/* Active cell indicator */
.ecw-box.active-cell::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 2px solid #007bff; /* Blue border for active cell */
    pointer-events: none; /* Allow clicks to pass through */
    box-sizing: border-box;
}

/* New style for the entire highlighted word */
.ecw-box.highlighted-word {
    background-color: #dbe9f7; /* Lighter blue for the selected word */
}

/* Ensure active cell is on top of word highlight */
.ecw-box.highlighted-word.active-cell {
    background-color: #FFF1D7; /* Keep the original active cell color */
    border-color: #007bff; /* Active cell border color */
}


/* Box States */
.ecw-boxnormal_unsel { background-color: #ffffff; border-color: #606060; color: #000000; }
.ecw-boxnormal_sel { background-color: #FFF1D7; border-color: #C00000; color: #000000; }
.ecw-boxcheated_unsel { background-color: #e6ffe6; border-color: #606060; color: #2080D0; } /* Lighter green for cheated */
.ecw-boxcheated_sel { background-color: #c4ffd4; border-color: #C00000; color: #2080D0; }
.ecw-boxerror_unsel { background-color: #FFF0F0; border-color: #606060; color: #BF0000; }
.ecw-boxerror_sel { background-color: #ffcccc; border-color: #C00000; color: #BF0000; } /* More prominent red for error */

.ecw-button {
    width: 100px; /* Increased width for buttons */
    padding: 8px 12px;
    font-family: "Segoe UI", "Verdana", "Arial", sans-serif;
    font-size: 0.9em;
    cursor: pointer;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: #e0e0e0;
    transition: background-color 0.2s, border-color 0.2s;
}

.ecw-button:hover {
    background-color: #d0d0d0;
    border-color: #bbb;
}

.ecw-button#okbutton {
    background-color: #4CAF50; /* Green for OK button */
    color: white;
    border-color: #4CAF50;
}

.ecw-button#okbutton:hover {
    background-color: #45a049;
    border-color: #45a049;
}

.ecw-button#cheatbutton {
    background-color: #FFC107; /* Orange for Cheat button */
    color: #333;
    border-color: #FFC107;
}

.ecw-button#cheatbutton:hover {
    background-color: #e0b000;
    border-color: #e0b000;
}


.ecw-cluebox {
    border-top: 1px solid #c0c0c0;
    border-bottom: 1px solid #c0c0c0;
    margin-top: 1em;
    padding: 0.5em 0;
}

.ecw-crosswordarea {
    background-color: #D0D8E0;
    border: 2px solid #808080;
    font-family: "Segoe UI", "Verdana", "Arial", sans-serif;
    font-size: small;
}

#crossword {
    border-collapse: collapse;
    table-layout: fixed;
}

.ecw-copyright {
    margin-top: 2em; /* More space for copyright */
    font-size: x-small;
    font-family: "Segoe UI", "Franklin Gothic Medium", "Arial", sans-serif;
    text-align: center; /* Center copyright */
    color: #666;
}

.ecw-wordlabel {
    text-transform: uppercase;
    margin: 0;
    font-size: 1.2em; /* Larger font for current word */
    color: #333;
}

.ecw-wordinfo {
    font-size: 0.8em;
    color: #808080;
    margin-bottom: 0.5em;
}

.ecw-worderror {
    color: #c00000;
    font-weight: bold;
    display: none;
    margin-top: 1em;
    background-color: #ffe6e6;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #c00000;
}

/* Specific elements that are hidden/shown by JS */
#waitmessage, #welcomemessage, #answerbox, #congratulations {
    text-align: center;
}

#crossword td {
    vertical-align: middle; /* Center content in cells */
    padding: 0; /* Remove default table cell padding */
}

/* Hidden input for mobile keyboard trigger */
#hiddenInput {
    position: absolute;
    left: -9999px; /* Move off-screen */
    top: -9999px;
    width: 1px;
    height: 1px;
    opacity: 0; /* Make it completely invisible */
    pointer-events: none; /* Do not block mouse events */
    z-index: -1;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .container {
        flex-direction: column; /* Stack elements on small screens */
        align-items: center; /* Center items when stacked */
    }
    .ecw-answerbox {
        width: 90%; /* Adjust width for smaller screens */
        max-width: 350px; /* Max width for answer box */
    }
    .main-app-wrapper {
        padding: 10px; /* Adjust padding for smaller screens */
    }
}
</style>

</head>
<body>

<div class="main-app-wrapper">
    <h1>ENGLISH CROSSWORD PUZZLE Grade 9 - Kurikulum Merdeka</h1>
    <h3><a href="https://7haridalam1minggu.blogspot.com/" style="text-decoration: none; color: inherit;">7haridalam1minggu.blogspot.com</a></h3>

    <div class="container">
        <div>
            <div id="waitmessage" class="ecw-answerbox">
                Please wait while the crossword is loaded...
            </div>

            <div id="crossword-container" class="ecw-crosswordarea" style="display: none;">
                <!-- Crossword grid will be dynamically inserted here by JavaScript -->
            </div>
        </div>

        <div class="right-panel">
            <div id="welcomemessage" class="ecw-answerbox" style="display:none;">
                <h3>Welcome!</h3>
                <p>Click a word in the puzzle to get started.</p>
            </div>

            <div id="answerbox" class="ecw-answerbox" style="display:none;">
                <h3 id="wordlabel" class="ecw-wordlabel"> &nbsp;</h3>
                <div id="wordinfo" class="ecw-wordinfo"> </div>
                <div id="wordclue" class="ecw-cluebox"> </div>
                <div id="worderror" class="ecw-worderror"></div>

                <table border="0" cellspacing="0" cellpadding="0" width="100%" style="margin-top:1em;"><tbody><tr><td>
                    <button id="cheatbutton" type="button" class="ecw-button" onclick="CrosswordGame.cheatClick();">Solve</button>
                </td><td align="right">
                    <button id="deselectButton" type="button" class="ecw-button" onclick="CrosswordGame.deselectCurrentWord();">Deselect</button>
                </td></tr></tbody></table>
            </div>

            <div id="congratulations" class="ecw-answerbox" style="display:none;">
                <h3>Congratulations!</h3>
                <p>You have completed this <a href="https://7haridalam1minggu.blogspot.com/" style="color: black; text-decoration:none;">crossword puzzle</a>.
                </p>
                <p>If you would like to be able to create interactive
                <a href="https://7haridalam1minggu.blogspot.com/" style="color: black; text-decoration:none;">crosswords</a>
                like this yourself, get <a href="https://7haridalam1minggu.blogspot.com/" target="_blank" rel="noopener noreferrer">More Crossword</a>
                from another times!
                </p>
            </div>
        </div>
    </div>

    <div style="margin-top: 1em; text-align: center;">
        <button id="checkbutton" type="button" onclick="CrosswordGame.checkClick();" style="display: none;">Check puzzle</button>
    </div>

    <div class="ecw-copyright">
        Created with EclipseCrossword, (C) Copyright 2000-2013 Green Eclipse. eclipsecrossword.com (Logic reimplemented)
    </div>
</div>

<!-- Hidden input field to trigger virtual keyboard on mobile -->
<input type="text" id="hiddenInput" aria-label="Hidden input for keyboard entry">

<script>
// Define a global object to encapsulate crossword logic
const CrosswordGame = (() => {
    // Puzzle Data (from original script)
    const CrosswordWidth = 19;
    const CrosswordHeight = 18;
    const Words = 20;
    const WordLength = [7, 7, 6, 9, 7, 5, 11, 9, 4, 7, 9, 11, 4, 12, 7, 7, 7, 4, 7, 5];
    const Word = ["LIBRARY", "BROUGHT", "ADVERB", "TRADITION", "PROMISE", "LEAVE", "CONJUNCTION", "SEMANTICS", "BEST", "FARTHER", "ADJECTIVE", "PREPOSITION", "GLAD", "INTERJECTION", "WRITTEN", "RUNNING", "ARTICLE", "POET", "PRONOUN", "TITLE"];
    const Clue = [
        "A place where you borrow books (7)",
        "The past tense of \"bring\" (7)",
        "A word that describes how an action is done (6)",
        "The opposite of \"modern\" (9)",
        "To tell someone you'll definitely do something (7)",
        "The opposite of \"arrive\" (5)",
        "A word that connects clauses or sentences (11)",
        "The study of how words are used in a language (9)",
        "The superlative form of \"good\" (4)",
        "The comparative form of \"far\" (7)",
        "A word that describes a noun (9)",
        "A word that shows position or direction (11)",
        "A word that means the same as \"happy\"",
        "A word that expresses strong emotion (12)",
        "A piece of writing about a particular subject (7)",
        "The present participle of \"run\" (7)",
        "The name of a book, movie, or song (5)",
        "The person who writes a poem (4)",
        "A word that takes the place of a noun (7)",
        "The name of a book, movie, or song (5)"
    ];
    const AnswerHash = [29357, 71107, 13415, 93675, 7492, 40467, 73035, 71174, 84174, 68242, 60482, 57403, 37424, 45425, 32148, 63362, 43474, 761, 12683, 85171];
    const WordX = [7, 3, 6, 10, 4, 11, 0, 6, 9, 4, 14, 16, 7, 1, 10, 18, 12, 6, 4, 7];
    const WordY = [0, 3, 6, 8, 10, 14, 15, 17, 0, 1, 2, 2, 3, 5, 5, 6, 8, 9, 10, 13];
    const LastHorizontalWord = 7;
    // const OnlyCheckOnce = false; // Not used in this direct input implementation

    const BadChars = "`~!@^*()_={[}]\\|:;\"',<>/?";

    // Game State Variables
    let TableAcrossWord = [];
    let TableDownWord = [];
    let CurrentWord = -1;
    let PrevWordHorizontal = false;
    let CrosswordFinished = false;
    let Initialized = false;
    let ActiveCell = null; // Stores the currently focused cell (TD element)
    let ActiveCellCoords = { x: -1, y: -1 }; // Stores x, y coordinates of the active cell

    // DOM Elements (cached for performance)
    let crosswordContainer;
    let waitMessage;
    let welcomeMessage;
    let answerBox;
    let wordLabel;
    let wordInfo;
    let wordClue;
    let wordError;
    let cheatButton;
    let checkButton;
    let congratulationsMessage;
    let deselectButton;
    let hiddenInput; // New: Reference to the hidden input
    let mainAppWrapper; // Reference to the main app wrapper for scrolling

    /**
     * Pads a number out to three characters (e.g., 5 -> "005").
     * @param {number} number The number to pad.
     * @returns {string} The padded number string.
     */
    function padNumber(number) {
        if (number < 10) return "00" + number;
        if (number < 100) return "0" + number;
        return "" + number;
    }

    /**
     * Returns the table cell (TD element) at a particular pair of coordinates.
     * @param {number} x The X-coordinate.
     * @param {number} y The Y-coordinate.
     * @returns {HTMLElement|null} The TD element or null if not found.
     */
    function cellAt(x, y) {
        if (x < 0 || x >= CrosswordWidth || y < 0 || y >= CrosswordHeight) {
            return null; // Return null for out-of-bounds cells
        }
        return document.getElementById("c" + padNumber(x) + padNumber(y));
    }

    /**
     * Changes the CSS class of the cells in a given word.
     * @param {number} wordNumber The index of the word.
     * @param {string} newStyle The new CSS class to apply.
     */
    function changeWordStyle(wordNumber, newStyle) {
        if (wordNumber < 0) return;
        const x = WordX[wordNumber];
        const y = WordY[wordNumber];

        if (wordNumber <= LastHorizontalWord) { // Horizontal word
            for (let i = 0; i < WordLength[wordNumber]; i++) {
                const cell = cellAt(x + i, y);
                if (cell) cell.className = newStyle;
            }
        } else { // Vertical word
            for (let i = 0; i < WordLength[wordNumber]; i++) {
                const cell = cellAt(x, y + i);
                if (cell) cell.className = newStyle;
            }
        }
    }

    /**
     * Clears all active/highlighted styles from all cells in the grid.
     */
    function clearAllCellHighlights() {
        for (let y = 0; y < CrosswordHeight; y++) {
            for (let x = 0; x < CrosswordWidth; x++) {
                const cell = cellAt(x, y);
                if (cell) {
                    cell.classList.remove('active-cell', 'highlighted-word');
                    // Ensure it reverts to normal unselected state if it was a selected state
                    if (cell.className.includes('_sel')) {
                        cell.className = cell.className.replace('_sel', '_unsel');
                    }
                }
            }
        }
    }

    /**
     * Highlights all cells belonging to a specific word.
     * @param {number} wordNumber The index of the word to highlight.
     */
    function highlightWord(wordNumber) {
        if (wordNumber < 0) return;
        const x = WordX[wordNumber];
        const y = WordY[wordNumber];

        if (wordNumber <= LastHorizontalWord) { // Horizontal word
            for (let i = 0; i < WordLength[wordNumber]; i++) {
                const cell = cellAt(x + i, y);
                if (cell) cell.classList.add('highlighted-word');
            }
        } else { // Vertical word
            for (let i = 0; i < WordLength[wordNumber]; i++) {
                const cell = cellAt(x, y + i);
                if (cell) cell.classList.add('highlighted-word');
            }
        }
    }

    /**
     * Deselects the current word, hiding the answer box and resetting styles.
     */
    function deselectCurrentWord() {
        if (CurrentWord < 0) return;

        answerBox.style.display = "none";
        clearAllCellHighlights(); // Clear all highlights
        CurrentWord = -1;
        welcomeMessage.style.display = "block"; // Show welcome message again
        hiddenInput.blur(); // Remove focus from hidden input
    }

    /**
     * Checks if the given word contains any disallowed characters.
     * @param {string} theirWord The word to check.
     * @returns {boolean} True if bad characters are found, false otherwise.
     */
    function containsBadChars(theirWord) {
        for (let i = 0; i < theirWord.length; i++) {
            if (BadChars.includes(theirWord.charAt(i))) return true;
        }
        return false;
    }

    /**
     * Generates a one-way hash for a word, matching the original EclipseCrossword logic.
     * @param {string} wordToHash The word to hash.
     * @returns {number} The calculated hash value.
     */
    function hashWord(wordToHash) {
        let x_hash = (wordToHash.charCodeAt(0) * 719) % 1138;
        let hash = 837;
        for (let i_hash = 1; i_hash <= wordToHash.length; i_hash++) {
            hash = (hash * i_hash + 5 + (wordToHash.charCodeAt(i_hash - 1) - 64) * x_hash) % 98503;
        }
        return hash;
    }

    /**
     * Updates the word label with the current state of the word in the grid.
     */
    function updateWordLabel() {
        if (CurrentWord < 0) return;

        const currentWordX = WordX[CurrentWord];
        const currentWordY = WordY[CurrentWord];
        let theirWord = "";

        for (let i = 0; i < WordLength[CurrentWord]; i++) {
            const cell = (CurrentWord <= LastHorizontalWord) ?
                cellAt(currentWordX + i, currentWordY) :
                cellAt(currentWordX, currentWordY + i);

            if (cell && cell.textContent && cell.textContent.trim().length > 0) {
                theirWord += cell.textContent.trim().toUpperCase();
            } else {
                theirWord += "&nbsp;"; // Use non-breaking space for empty cells
            }
        }
        wordLabel.innerHTML = theirWord;
    }

    /**
     * Scrolls the main app wrapper to bring the active cell into view.
     */
    function scrollToActiveCell() {
        if (!ActiveCell || !mainAppWrapper) return;

        const mainAppWrapperRect = mainAppWrapper.getBoundingClientRect();
        const activeCellRect = ActiveCell.getBoundingClientRect();

        // Calculate the desired scroll position to bring the active cell into view
        // We want the active cell to be visible, ideally near the top of the scrollable area
        let desiredScrollTop = mainAppWrapper.scrollTop + activeCellRect.top - mainAppWrapperRect.top - (mainAppWrapperRect.height / 4); // Adjust to be in the upper quarter

        // Ensure we don't scroll past the top (0) or bottom
        desiredScrollTop = Math.max(0, desiredScrollTop);
        desiredScrollTop = Math.min(desiredScrollTop, mainAppWrapper.scrollHeight - mainAppWrapper.clientHeight);

        mainAppWrapper.scrollTo({
            top: desiredScrollTop,
            behavior: 'smooth'
        });
    }

    /**
     * Selects a new cell and updates the current word context.
     * @param {number} x The x-coordinate of the cell.
     * @param {number} y The y-coordinate of the cell.
     */
    function selectCell(x, y) {
        const newCell = cellAt(x, y);
        if (!newCell || (TableAcrossWord[x][y] === -1 && TableDownWord[x][y] === -1)) {
            // If the new cell is not part of any word, or out of bounds, deselect everything.
            deselectCurrentWord();
            return;
        }

        // Clear all previous highlights before applying new ones
        clearAllCellHighlights();

        ActiveCell = newCell;
        ActiveCellCoords = { x, y };
        ActiveCell.classList.add('active-cell'); // Highlight the individual active cell

        welcomeMessage.style.display = "none";
        answerBox.style.display = "block";

        const oldCurrentWord = CurrentWord;

        // Determine the word to select based on click and previous direction
        if (TableAcrossWord[x][y] !== -1 && TableDownWord[x][y] !== -1) {
            // Intersection: switch direction if clicked on the same word again, or if no word was selected
            if (oldCurrentWord === TableAcrossWord[x][y] && PrevWordHorizontal) {
                CurrentWord = TableDownWord[x][y];
                PrevWordHorizontal = false;
            } else if (oldCurrentWord === TableDownWord[x][y] && !PrevWordHorizontal) {
                CurrentWord = TableAcrossWord[x][y];
                PrevWordHorizontal = true;
            } else {
                // Default to horizontal if no word was selected or switching to a new intersection
                CurrentWord = TableAcrossWord[x][y];
                PrevWordHorizontal = true;
            }
        } else if (TableAcrossWord[x][y] !== -1) {
            CurrentWord = TableAcrossWord[x][y];
            PrevWordHorizontal = true;
        } else if (TableDownWord[x][y] !== -1) {
            CurrentWord = TableDownWord[x][y];
            PrevWordHorizontal = false;
        }

        // Highlight the entire current word
        highlightWord(CurrentWord);

        wordInfo.textContent = ((CurrentWord <= LastHorizontalWord) ? "Across, " : "Down, ") + WordLength[CurrentWord] + " letters.";
        wordClue.textContent = Clue[CurrentWord];
        updateWordLabel(); // Update label with current word state
        wordError.style.display = "none";
        cheatButton.style.display = (Word.length === 0) ? "none" : "";

        // Focus the hidden input to bring up the keyboard with a slight delay for better mobile compatibility
        hiddenInput.value = ''; // Clear previous input
        setTimeout(() => {
            hiddenInput.focus();
            scrollToActiveCell(); // Scroll after focusing to ensure keyboard is up
        }, 50); // Small delay
    }

    /**
     * Handles character input from the hidden input field.
     * This event fires when the value of the input changes (e.g., a letter is typed).
     */
    function handleHiddenInputInput() {
        if (CrosswordFinished || !ActiveCell) return;

        const typedChar = hiddenInput.value.toUpperCase();
        hiddenInput.value = ''; // Clear the input immediately for next character

        if (typedChar.length === 1 && typedChar >= 'A' && typedChar <= 'Z') {
            if (containsBadChars(typedChar)) {
                wordError.innerHTML = "Invalid character. Please type only letters.";
                wordError.style.display = "block";
                return;
            } else {
                wordError.style.display = "none";
            }

            ActiveCell.textContent = typedChar;
            moveActiveCell(1); // Move forward
        }
    }

    /**
     * Handles special key presses (arrows, backspace, delete) from the hidden input field.
     */
    function handleHiddenInputKeyDown(event) {
        if (CrosswordFinished || !ActiveCell) return;

        const key = event.key.toUpperCase();
        let { x, y } = ActiveCellCoords;
        let nextX = x;
        let nextY = y;
        let moved = false;

        if (key === 'BACKSPACE' || key === 'DELETE') {
            event.preventDefault(); // Prevent default browser backspace behavior
            ActiveCell.textContent = ""; // Clear current cell
            moveActiveCell(-1); // Move backward
            moved = true;
        } else if (key === 'ARROWLEFT') {
            event.preventDefault();
            nextX--;
            PrevWordHorizontal = true; // Assume horizontal movement
            moved = true;
        } else if (key === 'ARROWRIGHT') {
            event.preventDefault();
            nextX++;
            PrevWordHorizontal = true; // Assume horizontal movement
            moved = true;
        } else if (key === 'ARROWUP') {
            event.preventDefault();
            nextY--;
            PrevWordHorizontal = false; // Assume vertical movement
            moved = true;
        } else if (key === 'ARROWDOWN') {
            event.preventDefault();
            nextY++;
            PrevWordHorizontal = false; // Assume vertical movement
            moved = true;
        }

        if (moved) {
            if (key.startsWith('ARROW')) {
                selectCell(nextX, nextY); // For arrow keys, directly select the new cell
            }
            updateWordLabel(); // Update label after cell content changes
        }
    }

    /**
     * Moves the active cell by a given step in the current word's direction.
     * @param {number} step The number of steps to move (e.g., 1 for forward, -1 for backward).
     */
    function moveActiveCell(step) {
        let { x, y } = ActiveCellCoords;
        let originalX = x;
        let originalY = y;

        // Calculate next cell coordinates based on current word direction
        if (CurrentWord <= LastHorizontalWord) { // Horizontal
            x += step;
        } else { // Vertical
            y += step;
        }

        // Find the next valid cell within the current word or grid
        let foundNextCell = false;
        let attemptX = x;
        let attemptY = y;

        // Loop to find the next valid cell if the calculated one is empty or out of bounds of the current word
        // This loop ensures we skip empty/black cells and stay within the current word if possible
        while (attemptX >= 0 && attemptX < CrosswordWidth && attemptY >= 0 && attemptY < CrosswordHeight) {
            const cellToCheck = cellAt(attemptX, attemptY);
            if (cellToCheck && (TableAcrossWord[attemptX][attemptY] === CurrentWord || TableDownWord[attemptX][attemptY] === CurrentWord)) {
                // Found a valid cell within the current word
                selectCell(attemptX, attemptY);
                foundNextCell = true;
                break;
            } else if (cellToCheck && (TableAcrossWord[attemptX][attemptY] !== -1 || TableDownWord[attemptX][attemptY] !== -1)) {
                // Found a valid cell, but it's part of an intersecting word, not the current one.
                // In this direct input mode, we want to stay within the current word's path.
                // If we've gone past the end of the current word, stop.
                const wordLength = WordLength[CurrentWord];
                const wordStartX = WordX[CurrentWord];
                const wordStartY = WordY[CurrentWord];

                let isPastEndOfWord = false;
                if (CurrentWord <= LastHorizontalWord) { // Horizontal
                    if (step > 0 && attemptX >= wordStartX + wordLength) isPastEndOfWord = true;
                    if (step < 0 && attemptX < wordStartX) isPastEndOfWord = true;
                } else { // Vertical
                    if (step > 0 && attemptY >= wordStartY + wordLength) isPastEndOfWord = true;
                    if (step < 0 && attemptY < wordStartY) isPastEndOfWord = true;
                }

                if (isPastEndOfWord) {
                    break; // Stop searching if we've gone past the word's logical end
                }
            }

            // Move to the next potential cell in the same direction
            if (CurrentWord <= LastHorizontalWord) { // Horizontal
                attemptX += step;
            } else { // Vertical
                attemptY += step;
            }
        }

        // If no valid next cell found within the current word's path, deselect
        if (!foundNextCell) {
            deselectCurrentWord();
        }
    }


    /**
     * Handles the click on the "Check puzzle" button, validating all entered words.
     */
    function checkClick() {
        if (CrosswordFinished) return;
        deselectCurrentWord(); // Deselect any active word before checking

        // Reset error styles
        for (let y = 0; y < CrosswordHeight; y++) {
            for (let x = 0; x < CrosswordWidth; x++) {
                const cell = cellAt(x, y);
                if (cell && cell.className.includes("ecw-boxerror_unsel")) {
                    cell.className = "ecw-box ecw-boxnormal_unsel";
                }
            }
        }

        let errorsFound = 0;
        let emptyFound = 0;

        for (let i = 0; i < Words; i++) {
            let userEntry = "";
            let isWordEmpty = false;
            for (let j = 0; j < WordLength[i]; j++) {
                const cell = (i <= LastHorizontalWord) ?
                    cellAt(WordX[i] + j, WordY[i]) :
                    cellAt(WordX[i], WordY[i] + j);

                if (cell && cell.textContent && cell.textContent.trim().length > 0) {
                    userEntry += cell.textContent.trim().toUpperCase();
                } else {
                    userEntry = ""; // Mark as empty if any cell is empty
                    isWordEmpty = true;
                    break;
                }
            }

            if (isWordEmpty) {
                emptyFound++;
            } else {
                // Check if the hashed user entry matches the stored hash
                if (hashWord(userEntry) !== AnswerHash[i]) {
                    errorsFound++;
                    changeWordStyle(i, "ecw-box ecw-boxerror_unsel");
                }
            }
        }

        // Display results
        let message = "";
        if (errorsFound > 0 && emptyFound > 0) {
            message = `${errorsFound} ${errorsFound > 1 ? "errors" : "error"} and ${emptyFound} ${emptyFound > 1 ? "incomplete words were" : "incomplete word was"} found.`;
        } else if (errorsFound > 0) {
            message = `${errorsFound} ${errorsFound > 1 ? "errors were" : "error was"} found.`;
        } else if (emptyFound > 0) {
            message = `No errors were found, but ${emptyFound} ${emptyFound > 1 ? "incomplete words were" : "incomplete word was"} found.`;
        }

        if (errorsFound + emptyFound > 0) {
            welcomeMessage.innerHTML = `<h3>Results</h3><p>${message}</p>`;
            welcomeMessage.style.display = "block";
        }

        if (errorsFound === 0 && emptyFound === 0) {
            CrosswordFinished = true;
            checkButton.style.display = "none";
            congratulationsMessage.style.display = "block";
            welcomeMessage.style.display = "none";
        }
    }

    /**
     * Handles the click on the "Solve" (cheat) button.
     */
    function cheatClick() {
        if (CrosswordFinished || CurrentWord === -1) return; // Ensure a word is selected

        const wordToSolve = Word[CurrentWord];
        const x = WordX[CurrentWord];
        const y = WordY[CurrentWord];

        for (let i = 0; i < WordLength[CurrentWord]; i++) {
            const cell = (CurrentWord <= LastHorizontalWord) ?
                cellAt(x + i, y) :
                cellAt(x, y + i);
            if (cell) {
                cell.textContent = wordToSolve.charAt(i);
            }
        }
        changeWordStyle(CurrentWord, "ecw-box ecw-boxcheated_unsel");
        updateWordLabel(); // Update label after solving
        deselectCurrentWord(); // Deselect after solving
    }

    /**
     * Initializes the crossword grid and sets up event listeners.
     */
    function initializeCrosswordGrid() {
        // Initialize cell-to-word arrays
        TableAcrossWord = Array(CrosswordWidth).fill(0).map(() => Array(CrosswordHeight).fill(-1));
        TableDownWord = Array(CrosswordWidth).fill(0).map(() => Array(CrosswordHeight).fill(-1));

        // Populate TableAcrossWord for horizontal words
        for (let i = 0; i <= LastHorizontalWord; i++) {
            const x = WordX[i];
            const y = WordY[i];
            for (let j = 0; j < WordLength[i]; j++) {
                TableAcrossWord[x + j][y] = i;
            }
        }

        // Populate TableDownWord for vertical words
        for (let i = LastHorizontalWord + 1; i < Words; i++) {
            const x = WordX[i];
            const y = WordY[i];
            for (let j = 0; j < WordLength[i]; j++) {
                TableDownWord[x][y + j] = i;
            }
        }

        // Create the crossword table dynamically
        const crosswordTable = document.createElement("table");
        crosswordTable.id = "crossword";
        crosswordTable.style.cssText = "border-collapse: collapse;";

        for (let y = 0; y < CrosswordHeight; y++) {
            const row = crosswordTable.insertRow();
            for (let x = 0; x < CrosswordWidth; x++) {
                const cell = row.insertCell();
                if (TableAcrossWord[x][y] !== -1 || TableDownWord[x][y] !== -1) {
                    cell.id = "c" + padNumber(x) + padNumber(y);
                    cell.className = "ecw-box ecw-boxnormal_unsel";
                    cell.addEventListener("click", (event) => {
                        const target = event.target;
                        const clickedX = parseInt(target.id.substring(1, 4), 10);
                        const clickedY = parseInt(target.id.substring(4, 7), 10);
                        selectCell(clickedX, clickedY);
                    });
                    cell.textContent = ""; // Ensure empty cells
                } else {
                    // Empty cell, no interaction
                }
            }
        }

        crosswordContainer.appendChild(crosswordTable);

        // Hide wait message and show crossword
        waitMessage.style.display = "none";
        crosswordContainer.style.display = "block";
        welcomeMessage.style.display = "block"; // Show welcome message initially
        checkButton.style.display = "block"; // Show check button initially
        Initialized = true;
    }

    /**
     * Caches DOM elements and sets up initial event listeners.
     */
    function cacheDOMElements() {
        crosswordContainer = document.getElementById("crossword-container");
        waitMessage = document.getElementById("waitmessage");
        welcomeMessage = document.getElementById("welcomemessage");
        answerBox = document.getElementById("answerbox");
        wordLabel = document.getElementById("wordlabel");
        wordInfo = document.getElementById("wordinfo");
        wordClue = document.getElementById("wordclue");
        wordError = document.getElementById("worderror");
        cheatButton = document.getElementById("cheatbutton");
        checkButton = document.getElementById("checkbutton");
        congratulationsMessage = document.getElementById("congratulations");
        deselectButton = document.getElementById("deselectButton");
        hiddenInput = document.getElementById("hiddenInput"); // Cache the new hidden input
        mainAppWrapper = document.querySelector('.main-app-wrapper'); // Cache the main app wrapper

        // Add event listeners to the hidden input
        hiddenInput.addEventListener("input", handleHiddenInputInput);
        hiddenInput.addEventListener("keydown", handleHiddenInputKeyDown);
    }

    // Public API for the CrosswordGame module
    return {
        init: () => {
            cacheDOMElements();
            initializeCrosswordGrid();
        },
        deselectCurrentWord, // Exposed for the deselect button
        checkClick,
        cheatClick
    };
})();

// Initialize the crossword puzzle when the DOM is fully loaded
document.addEventListener("DOMContentLoaded", CrosswordGame.init);
</script>

</body>
</html>
